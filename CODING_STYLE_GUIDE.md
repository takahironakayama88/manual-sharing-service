# AI Code Generation Style Guide

このドキュメントは、本プロジェクトにおけるAIによるコード生成のためのコーディングスタイルガイドです。生成される全てのコードは、以下の原則に厳密に従う必要があります。

このガイドは2つのパートで構成されています。
1.  **Part 1: 建築的原則** - プロダクトの堅牢性、拡張性、保守性を担保します。
2.  **Part 2: UX実装ガイドライン** - プロダクトが提供するユーザー体験の品質を最大化します。

両方の原則を遵守することで、技術的にもユーザー体験的にも高品質なアプリケーションを構築します。

---

## Part 1: Architectural Principles for Robustness & Scalability
**(技術アーキテクト 中島 聡 策定)**

このルールは、将来の拡張性と保守性を最大化し、技術的負債を最小限に抑えるための**「設計原則」**である。

### 1.1. 基本原則
- **言語:** `TypeScript` を採用し、`"strict": true` を徹底する。`any` 型の使用は原則禁止。
- **フォーマッター:** `Prettier` を導入し、コミット時に自動整形を強制する。
- **リンター:** `ESLint` を導入し、`eslint:recommended` 及び `plugin:@typescript-eslint/recommended` を基盤とする。未使用の変数や`console.log`はエラーとして検知すること。

### 1.2. ディレクトリ構造
- Next.jsの `app` Routerをベースとし、以下の構造を基本とする。
  - `app/`: ルーティングとページ。UIとロジックを明確に分離する。
  - `components/`: 再利用可能なUIコンポーネント。
  - `lib/`: プロジェクト固有のヘルパー関数、クライアントライブラリのインスタンス化など。
  - `hooks/`: 再利用可能なカスタムフック。
  - `types/`: プロジェクト全体で利用する型定義。

### 1.3. API（バックエンド）規律
- **認証:** 全てのAPIルートは、デフォルトで保護されているものと見なす。Supabaseのセッション情報をサーバーサイドで検証する処理を必ず経由すること。
- **責務の分離:** APIルートはリクエストの検証とレスポンスの返却に専念し、複雑なビジネスロジックは `lib/` 内の関数に切り出す。
- **エラーハンドリング:** APIにおけるエラーは、適切なHTTPステータスコード（例: `400`, `401`, `500`）と共に、定型化されたJSON `{ "error": "メッセージ" }` 形式で返す。
- **環境変数:** 機密情報は全て環境変数 (`.env.local`) で管理する。コードへのハードコーディングは一切禁止。

### 1.4. データベース規律
- **クライアントからの直接アクセス禁止:** ブラウザからSupabaseのデータベースを直接書き換える処理（`.insert()`, `.update()`, `.delete()`）を**絶対に**呼び出さないこと。全ての書き込み処理はサーバーサイドのAPIルートを経由する。
- **データ取得:** `Row Level Security (RLS)` をSupabase側で有効にし、クライアントからの読み取りも原則RLSポリシーに従う。
- **型付け:** `supabase gen types typescript` で生成した型をプロジェクト全体で共有し、DBスキーマとコードの型を同期させる。

### 1.5. 状態管理
- サーバーデータ（SWRやTanStack Queryのキャッシュ）とUI状態（`useState`）を明確に区別する。
- 複雑なUI状態の共有には `Zustand` のような軽量なライブラリの導入を検討する。

---

## Part 2: UX Implementation Guidelines for a High-Quality User Experience
**(UI/UX設計 深津 貴之 策定)**

このルールは、我々のプロダクトが「使いやすく、心地よく、そして美しい」体験を提供するための**「実装ガイドライン」**である。

### 2.1. コンポーネント設計
- **Atomic Designの思想:** コンポーネントを `atoms`, `molecules`, `organisms` の粒度で `components/` 内に整理し、再利用性と一貫性を担保する。
- **単一責任の原則:** 1つのコンポーネントは1つのことだけをうまくやる。ロジックはカスタムフック等に分離する。
- **命名規則:** コンポーネントは `PascalCase` (`PrimaryButton.tsx`)、propsは `camelCase` とする。

### 2.2. スタイリング
- **`Tailwind CSS`** を採用する。Utility-Firstのアプローチにより、迅速なUI構築とデザインシステムへの準拠を両立する。
- **独自CSSの禁止:** 原則として、グローバルCSSやコンポーネント固有のCSSファイルは作成せず、全てのスタイリングはTailwindのクラスで表現する。
- **動的スタイルの適用:** `clsx` のようなライブラリを用いて、クラス名を動的に結合して行う。

### 2.3. アクセシビリティ (a11y)
- **セマンティックHTML:** `div` や `span` を乱用せず、`<nav>`, `<main>`, `<button>`, `<label>` のような意味的に正しいHTMLタグを常に使用する。
- **フォーム:** 全ての `input` 要素には、対応する `label` 要素を必ず提供する。
- **キーボード操作:** 全てのインタラクティブな要素は、キーボードでも操作可能でなければならない。

### 2.4. ユーザー体験の品質
- **ローディング状態の明示:** データ取得中や処理実行中には、必ずローディングスピナーやスケルトンスクリーンを表示する。
- **エラー状態の配慮:** エラーが発生した場合、ユーザーが理解できる言葉でフィードバックを提供する。
- **楽観的UI (Optimistic UI):** 成功率が高い操作については、APIのレスポンスを待たずにUIを即座に更新し、体感速度を向上させる。

### 2.5. 国際化 (i18n)
- **文字列のハードコーディング禁止:** ユーザーの目に触れる全てのテキストは、言語リソースファイル（例: `ja.json`）から取得する (`next-intl` 等を利用)。
- **日付・数値のフォーマット:** `Intl`オブジェクトやライブラリを用い、ユーザーのロケールに合わせた形式で表示する。
